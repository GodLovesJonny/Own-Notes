{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fnil MS Sans Serif;}{\f1\fnil\fcharset2 Symbol;}{\f2\fswiss\fprq2 System;}{\f3\fnil\fcharset134 \'cb\'ce\'cc\'e5;}}
{\colortbl\red0\green0\blue0;}
\deflang1033{\info{\horzdoc }{\*\fchars !),.:\'3b?\}]\'a1\'a2\'a1\'a3\'a1\'a4\'a1\'a5\'a1\'a6\'a1\'a7\'a1\'a8\'a1\'a9\'a1\'aa\'a1\'ab\'a1\'ac\'a1\'ad\'a1\'af\'a1\'b1\'a1\'b3\'a1\'b5\'a1\'b7\'a1\'b9\'a1\'bb\'a1\'bd\'a1\'bf\'a1\'c3\'a3\'a1\'a3\'a2\'a3\'a7\'a3\'a9\'a3\'ac\'a3\'ae\'a3\'ba\'a3\'bb\'a3\'bf\'a3\'dd\'a3\'e0}{\*\lchars ([\{\'a1\'ae\'a1\'b0\'a1\'b2\'a1\'b4\'a1\'b6\'a1\'b8\'a1\'ba\'a1\'bc\'a1\'be\'a3\'a8\'a3\'db\'a3\'fb\'a3\'ae\'a1\'a4}}
\pard\nowwrap\nooverflow\plain\f3\fs21 [VRML]
\par 
\par The Virtual Reality Modeling Language
\par 
\par    Version 1.0 Specification
\par 
\par 26-MAY-95
\par 
\par      Gavin Bell, Silicon Graphics, Inc.
\par      Anthony Parisi, Intervista Software
\par      Mark Pesce, VRML List Moderator
\par 
\par -------------------------------------------------------------------------------
\par 
\par Acknowledgements
\par 
\par      I want to thank three people who have been absolutely instrumental in
\par      the design process: Brian Behlendorf, whose drive (and disk space)
\par      made this process happen; and Tony Parisi and Gavin Bell, the final
\par      authors of this specification, who have put in a great deal of design
\par      work, ensuring that we have a satisfactory product. My hat goes off
\par      to all of them, and to all of you who have made this process a
\par      success.
\par 
\par Mark Pesce
\par 
\par      I would like to add a personal note of thanks to Jan Hardenbergh of
\par      Oki Advanced Products for his diligent efforts to keep the
\par      specification process on track, and his invaluable editing
\par      assistance. I would also like to acknowledge Chris Marrin of Silicon
\par      Graphics for his timely contributions to the final design.
\par 
\par Tony Parisi
\par 
\par Revision History
\par 
\par    * First Draft - November 2, 1994
\par    * Second Draft - May 8, 1995
\par    * Third Draft - May 26, 1995
\par 
\par Table of Contents
\par 
\par    *  Introduction
\par 
\par         o  VRML Mission Statement
\par         o  History
\par         o  Version 1.0 Requirements
\par 
\par    *  Language Specification
\par 
\par         o  Language Basics
\par         o  Coordinate System
\par         o  Fields
\par         o  Nodes
\par         o  Instancing
\par         o  Extensibility
\par         o  An Example
\par 
\par    *  Browser Considerations
\par 
\par         o  File Extensions
\par         o  MIME Types
\par 
\par -------------------------------------------------------------------------------
\par 
\par    Introduction
\par 
\par The Virtual Reality Modeling Language (VRML) is a language for describing
\par multi-participant interactive simulations -- virtual worlds networked via the
\par global Internet and hyperlinked with the World Wide Web. All aspects of virtual
\par world display, interaction and internetworking can be specified using VRML. It
\par is the intention of its designers that VRML become the standard language for
\par interactive simulation within the World Wide Web.
\par 
\par The first version of VRML allows for the creation of virtual worlds with
\par limited interactive behavior. These worlds can contain objects which have
\par hyperlinks to other worlds, HTML documents or other valid MIME types. When the
\par user selects an object with a hyperlink, the appropriate MIME viewer is
\par launched. When the user selects a link to a VRML document from within a
\par correctly configured WWW browser, a VRML viewer is launched. Thus VRML viewers
\par are the perfect companion applications to standard WWW browsers for navigating
\par and visualizing the Web. Future versions of VRML will allow for richer
\par behaviors, including animations, motion physics and real-time multi-user
\par interaction.
\par 
\par This document specifies the features and syntax of Version 1.0 of VRML.
\par 
\par    VRML Mission Statement
\par 
\par The history of the development of the Internet has had three distinct phases;
\par first, the development of the TCP/IP infrastructure which allowed documents and
\par data to be stored in a proximally independent way; that is, Internet provided a
\par layer of abstraction between data sets and the hosts which manipulated them.
\par While this abstraction was useful, it was also confusing; without any clear
\par sense of "what went where", access to Internet was restricted to the class of
\par sysops/net surfers who could maintain internal cognitive maps of the data
\par space.
\par 
\par Next, Tim Berners-Lee's work at CERN, where he developed the hypermedia system
\par known as World Wide Web, added another layer of abstraction to the existing
\par structure. This abstraction provided an "addressing" scheme, a unique
\par identifier (the Universal Resource Locator), which could tell anyone "where to
\par go and how to get there" for any piece of data within the Web. While useful, it
\par lacked dimensionality; there's no there there within the web, and the only type
\par of navigation permissible (other than surfing) is by direct reference. In other
\par words, I can only tell you how to get to the VRML Forum home page by saying,
\par "http://www.wired.com/", which is not human-centered data. In fact, I need to
\par make an effort to remember it at all. So, while the World Wide Web provides a
\par retrieval mechanism to complement the existing storage mechanism, it leaves a
\par lot to be desired, particularly for human beings.
\par 
\par Finally, we move to "perceptualized" Internetworks, where the data has been
\par sensualized, that is, rendered sensually. If something is represented
\par sensually, it is possible to make sense of it. VRML is an attempt (how
\par successful, only time and effort will tell) to place humans at the center of
\par the Internet, ordering its universe to our whims. In order to do that, the most
\par important single element is a standard that defines the particularities of
\par perception. Virtual Reality Modeling Language is that standard, designed to be
\par a universal description language for multi-participant simulations.
\par 
\par These three phases, storage, retrieval, and perceptualization are analogous to
\par the human process of consciousness, as expressed in terms of semantics and
\par cognitive science. Events occur and are recorded (memory); inferences are drawn
\par from memory (associations), and from sets of related events, maps of the
\par universe are created (cognitive perception). What is important to remember is
\par that the map is not the territory, and we should avoid becoming trapped in any
\par single representation or world-view. Although we need to design to avoid
\par disorientation, we should always push the envelope in the kinds of experience
\par we can bring into manifestation!
\par 
\par This document is the living proof of the success of a process that was
\par committed to being open and flexible, responsive to the needs of a growing Web
\par community. Rather than re-invent the wheel, we have adapted an existing
\par specification (Open Inventor) as the basis from which our own work can grow,
\par saving years of design work and perhaps many mistakes. Now our real work can
\par begin; that of rendering our noospheric space.
\par 
\par    History
\par 
\par VRML was conceived in the spring of 1994 at the first annual World Wide Web
\par Conference in Geneva, Switzerland. Tim Berners-Lee and Dave Raggett organized a
\par Birds-of-a-Feather (BOF) session to discuss Virtual Reality interfaces to the
\par World Wide Web. Several BOF attendees described projects already underway to
\par build three dimensional graphical visualization tools which interoperate with
\par the Web. Attendees agreed on the need for these tools to have a common language
\par for specifying 3D scene description and WWW hyperlinks -- an analog of HTML for
\par virtual reality. The term Virtual Reality Markup Language (VRML) was coined,
\par and the group resolved to begin specification work after the conference. The
\par word 'Markup' was later changed to 'Modeling' to reflect the graphical nature
\par of VRML.
\par 
\par Shortly after the Geneva BOF session, the www-vrml mailing list was created to
\par discuss the development of a specification for the first version of VRML. The
\par response to the list invitation was overwhelming: within a week, there were
\par over a thousand members. After an initial settling-in period, list moderator
\par Mark Pesce of Labyrinth Group announced his intention to have a draft version
\par of the specification ready by the WWW Fall 1994 conference, a mere five months
\par away. There was general agreement on the list that, while this schedule was
\par aggressive, it was achievable provided that the requirements for the first
\par version were not too ambitious and that VRML could be adapted from an existing
\par solution. The list quickly agreed upon a set of requirements for the first
\par version, and began a search for technologies which could be adapted to fit the
\par needs of VRML.
\par 
\par The search for existing technologies turned up a several worthwhile candidates.
\par After much deliberation the list came to a consensus: the Open Inventor ASCII
\par File Format from Silicon Graphics, Inc. The Inventor File Format supports
\par complete descriptions of 3D scenes with polygonally rendered objects, lighting,
\par materials, ambient properties and realism effects. A subset of the Inventor
\par File Format, with extensions to support networking, forms the basis of VRML.
\par Gavin Bell of Silicon Graphics has adapted the Inventor File Format for VRML,
\par with design input from the mailing list. SGI has publicly stated that the file
\par format is available for use in the open market, and have contributed a file
\par format parser into the public domain to bootstrap VRML viewer development.
\par 
\par    Version 1.0 Requirements
\par 
\par VRML 1.0 is designed to meet the following requirements:
\par 
\par    *  Platform independence
\par    *  Extensibility
\par    *  Ability to work well over low-bandwidth connections
\par 
\par As with HTML, the above are absolute requirements for a network language
\par standard; they should need little explanation here.
\par 
\par Early on the designers decided that VRML would not be an extension to HTML.
\par HTML is designed for text, not graphics. Also, VRML requires even more finely
\par tuned network optimizations than HTML; it is expected that a typical VRML scene
\par will be composed of many more "inline" objects and served up by many more
\par servers than a typical HTML document. Moreover, HTML is an accepted standard,
\par with existing implementations that depend on it. To impede the HTML design
\par process with VRML issues and constrain the VRML design process with HTML
\par compatibility concerns would be to do both languages a disservice. As a network
\par language, VRML will succeed or fail independent of HTML.
\par 
\par It was also decided that, except for the hyperlinking feature, the first
\par version of VRML would not support interactive behaviors. This was a practical
\par decision intended to streamline design and implementation. Design of a language
\par for describing interactive behaviors is a big job, especially when the language
\par needs to express behaviors of objects communicating on a network. Such
\par languages do exist; if we had chosen one of them, we would have risked getting
\par into a "language war." People don't get excited about the syntax of a language
\par for describing polygonal objects; people get very excited about the syntax of
\par real languages for writing programs. Religious wars can extend the design
\par process by months or years. In addition, networked inter-object operation
\par requires brokering services such as those provided by CORBA or OLE, services
\par which don't exist yet within WWW; we would have had to invent them. Finally, by
\par keeping behaviors out of Version 1, we have made it a much smaller task to
\par implement a viewer. We acknowledge that support for arbitrary interactive
\par behaviors is critical to the long-term success of VRML; they will be included
\par in Version 2.
\par 
\par -------------------------------------------------------------------------------
\par 
\par    Language Specification
\par 
\par The language specification is divided into the following sections:
\par 
\par    *  Language Basics
\par    *  Coordinate System
\par    *  Fields
\par    *  Nodes
\par    *  Instancing
\par    *  Extensibility
\par    *  An Example
\par 
\par    Language Basics
\par 
\par At the highest level of abstraction, VRML is just a way for objects to read and
\par write themselves. Theoretically, the objects can contain anything -- 3D
\par geometry, MIDI data, JPEG images, anything. VRML defines a set of objects
\par useful for doing 3D graphics. These objects are called Nodes.
\par 
\par Nodes are arranged in hierarchical structures called scene graphs. Scene graphs
\par are more than just a collection of nodes; the scene graph defines an ordering
\par for the nodes. The scene graph has a notion of state -- nodes earlier in the
\par scene can affect nodes that appear later in the scene. For example, a Rotation
\par or Material node will affect the nodes after it in the scene. A mechanism is
\par defined to limit the effects of properties (separator nodes), allowing parts of
\par the scene graph to be functionally isolated from other parts.
\par 
\par A node has the following characteristics:
\par 
\par    *  What kind of object it is. A node might be a cube, a sphere, a texture
\par      map, a transformation, etc.
\par 
\par    *  The parameters that distinguish this node from other nodes of the same
\par      type. For example, each Sphere node might have a different radius, and
\par      different texture maps nodes will certainly contain different images to
\par      use as the texture maps. These parameters are called Fields. A node can
\par      have 0 or more fields.
\par 
\par    *  A name to identify this node. Being able to name nodes and refer to them
\par      elsewhere is very powerful; it allows a scene's author to give hints to
\par      applications using the scene about what is in the scene, and creates
\par      possibilities for very powerful scripting extensions. Nodes do not have to
\par      be named, but if they are named, they can have only one name. However,
\par      names do not have to be unique-- several different nodes may be given the
\par      same name.
\par 
\par    *  Child nodes. Object hierarchy is implemented by allowing some types of
\par      nodes to contain other nodes. Parent nodes traverse their children in
\par      order during rendering. Nodes that may have children are referred to as
\par      group nodes. Group nodes can have zero or more children.
\par 
\par The syntax chosen to represent these pieces of information is straightforward:
\par 
\par DEF objectname objecttype \{ fields  children \}
\par 
\par Only the object type and curly braces are required; nodes may or may not have a
\par name, fields, and children.
\par 
\par Node names must not begin with a digit, and must not contain spaces or control
\par characters, single or double quote characters, backslashes, curly braces, the
\par plus character or the period character.
\par 
\par For example, this file contains a simple scene defining a view of a red cone
\par and a blue sphere, lit by a directional light:
\par 
\par #VRML V1.0 ascii
\par Separator \{
\par     DirectionalLight \{
\par         direction 0 0 -1  # Light shining from viewer into scene
\par     \}
\par     PerspectiveCamera \{
\par         position    -8.6 2.1 5.6
\par         orientation -0.1352 -0.9831 -0.1233  1.1417
\par         focalDistance       10.84
\par     \}
\par     Separator \{   # The red sphere
\par         Material \{
\par             diffuseColor 1 0 0   # Red
\par         \}
\par         Translation \{ translation 3 0 1 \}
\par         Sphere \{ radius 2.3 \}
\par     \}
\par     Separator \{  # The blue cube
\par         Material \{
\par             diffuseColor 0 0 1  # Blue
\par         \}
\par         Transform \{
\par             translation -2.4 .2 1
\par             rotation 0 1 1  .9
\par         \}
\par         Cube \{\}
\par     \}
\par 
\par 
\par General Syntax
\par 
\par For easy identification of VRML files, every VRML file must begin with the
\par characters:
\par 
\par #VRML V1.0 ascii
\par 
\par Any characters after these on the same line are ignored. The line is terminated
\par by either the ASCII newline or carriage-return characters.
\par 
\par The '#' character begins a comment; all characters until the next newline or
\par carriage return are ignored. The only exception to this is within string
\par fields, where the '#' character will be part of the string.
\par 
\par Note: Comments and whitespace may not be preserved; in particular, a VRML
\par document server may strip comments and extraneous whitespace from a VRML file
\par before transmitting it. Info nodes should be used for persistent information
\par like copyrights or author information. Info nodes could also be used for object
\par descriptions.
\par 
\par Blanks, tabs, newlines and carriage returns are whitespace characters wherever
\par they appear outside of string fields. One or more whitespace characters
\par separates the syntactical entities in VRML files, where necessary.
\par 
\par After the required header, a VRML file contains exactly one VRML node. That
\par node may of course be a group node, containing any number of other nodes.
\par 
\par    Coordinate System
\par 
\par VRML uses a cartesian, right-handed, 3-dimensional coordinate system. By
\par default, objects are projected onto a 2-dimensional device by projecting them
\par in the direction of the positive Z axis, with the positive X axis to the right
\par and the positive Y axis up. A camera or modeling transformation may be used to
\par alter this default projection.
\par 
\par The standard unit for lengths and distances specified is meters. The standard
\par unit for angles is radians.
\par 
\par    Fields
\par 
\par There are two general classes of fields; fields that contain a single value
\par (where a value may be a single number, a vector, or even an image), and fields
\par that contain multiple values. Single-valued fields all have names that begin
\par with "SF", multiple-valued fields have names that begin with "MF". Each field
\par type defines the format for the values it writes.
\par 
\par Multiple-valued fields are written as a series of values separated by commas,
\par all enclosed in square brackets. If the field has zero values then only the
\par square brackets ("[]") are written. The last may optionally be followed by a
\par comma. If the field has exactly one value, the brackets may be omitted and just
\par the value written. For example, all of the following are valid for a
\par multiple-valued field containing the single integer value 1:
\par 
\par 
\par [1,]
\par [ 1 ]
\par 
\par SFBitMask
\par 
\par A single-value field that contains a mask of bit flags. Nodes that use this
\par field class define mnemonic names for the bit flags. SFBitMasks are written to
\par file as one or more mnemonic enumerated type names, in this format:
\par 
\par ( flag1 | flag2 | ... )
\par 
\par If only one flag is used in a mask, the parentheses are optional. These names
\par differ among uses of this field in various node classes.
\par 
\par SFBool
\par 
\par A field containing a single boolean (true or false) value. SFBools may be
\par written as 0 (representing FALSE), 1, TRUE, or FALSE.
\par 
\par SFColor
\par 
\par A single-value field containing a color. SFColors are written to file as an RGB
\par triple of floating point numbers in standard scientific notation, in the range
\par 0.0 to 1.0.
\par 
\par SFEnum
\par 
\par A single-value field that contains an enumerated type value. Nodes that use
\par this field class define mnemonic names for the values. SFEnums are written to
\par file as a mnemonic enumerated type name. The name differs among uses of this
\par field in various node classes.
\par 
\par SFFloat
\par 
\par A field that contains one single-precision floating point number. SFFloats are
\par written to file in standard scientific notation.
\par 
\par SFImage
\par 
\par A field that contain an uncompressed 2-dimensional color or greyscale image.
\par 
\par SFImages are written to file as three integers representing the width, height
\par and number of components in the image, followed by width*height hexadecimal
\par values representing the pixels in the image, separated by whitespace. A
\par one-component image will have one-byte hexadecimal values representing the
\par intensity of the image. For example, 0xFF is full intensity, 0x00 is no
\par intensity. A two-component image puts the intensity in the first (high) byte
\par and the transparency in the second (low) byte. Pixels in a three-component
\par image have the red component in the first (high) byte, followed by the green
\par and blue components (so 0xFF0000 is red). Four-component images put the
\par transparency byte after red/green/blue (so 0x0000FF80 is semi-transparent
\par blue). A value of 1.0 is completely transparent, 0.0 is completely opaque.
\par Note: each pixel is actually read as a single unsigned number, so a 3-component
\par pixel with value "0x0000FF" can also be written as "0xFF" or "255" (decimal).
\par Pixels are specified from left to right, bottom to top. The first hexadecimal
\par value is the lower left pixel of the image, and the last value is the upper
\par right pixel.
\par 
\par For example,
\par 
\par 1 2 1 0xFF 0x00
\par 
\par is a 1 pixel wide by 2 pixel high greyscale image, with the bottom pixel white
\par and the top pixel black. And:
\par 
\par 2 4 3 0xFF0000 0xFF00 0 0 0 0 0xFFFFFF 0xFFFF00
\par 
\par is a 2 pixel wide by 4 pixel high RGB image, with the bottom left pixel red,
\par the bottom right pixel green, the two middle rows of pixels black, the top left
\par pixel white, and the top right pixel yellow.
\par 
\par SFLong
\par 
\par A field containing a single long (32-bit) integer. SFLongs are written to file
\par as an integer in decimal, hexadecimal (beginning with '0x') or octal (beginning
\par with '0') format.
\par 
\par SFMatrix
\par 
\par A field containing a transformation matrix. SFMatrices are written to file in
\par row-major order as 16 floating point numbers separated by whitespace. For
\par example, a matrix expressing a translation of 7.3 units along the X axis is
\par written as:
\par 
\par 1 0 0 0  0 1 0 0  0 0 1 0  7.3 0 0 1
\par 
\par SFRotation
\par 
\par A field containing an arbitrary rotation. SFRotations are written to file as
\par four floating point values separated by whitespace. The 4 values represent an
\par axis of rotation followed by the amount of right-handed rotation about that
\par axis, in radians. For example, a 180 degree rotation about the Y axis is:
\par 
\par 0 1 0  3.14159265
\par 
\par SFString
\par 
\par A field containing an ASCII string (sequence of characters). SFStrings are
\par written to file as a sequence of ASCII characters in double quotes (optional if
\par the string doesn't contain any whitespace). Any characters (including newlines)
\par may appear within the quotes. To include a double quote character within the
\par string, precede it with a backslash. For example:
\par 
\par Testing
\par "One, Two, Three"
\par "He said, \\"Immel did it!\\""
\par 
\par are all valid strings.
\par 
\par SFVec2f
\par 
\par Field containing a two-dimensional vector. SFVec2fs are written to file as a
\par pair of floating point values separated by whitespace.
\par 
\par SFVec3f
\par 
\par Field containing a three-dimensional vector. SFVec3fs are written to file as
\par three floating point values separated by whitespace.
\par 
\par MFColor
\par 
\par A multiple-value field that contains any number of RGB colors. MFColors are
\par written to file as one or more RGB triples of floating point numbers in
\par standard scientific notation. When more than one value is present, all of the
\par values must be enclosed in square brackets and separated by commas. For
\par example:
\par 
\par [ 1.0 0.0 0.0, 0 1 0, 0 0 1 ]
\par 
\par represents the three colors red, green, and blue.
\par 
\par MFLong
\par 
\par A multiple-value field that contains any number of long (32-bit) integers.
\par MFLongs are written to file as one or more integer values, in decimal,
\par hexadecimal or octal format. When more than one value is present, all the
\par values are enclosed in square brackets and separated by commas; for example:
\par 
\par [ 17, -0xE20, -518820 ]
\par 
\par MFVec2f
\par 
\par A multiple-value field that contains any number of two-dimensional vectors.
\par MFVec2fs are written to file as one or more pairs of floating point values
\par separated by whitespace. When more than one value is present, all of the values
\par are enclosed in square brackets and separated by commas; for example:
\par 
\par [ 0 0, 1.2 3.4, 98.6 -4e1 ]
\par 
\par MFVec3f
\par 
\par A multiple-value field that contains any number of three-dimensional vectors.
\par MFVec3fs are written to file as one or more triples of floating point values
\par separated by whitespace. When more than one value is present, all of the values
\par are enclosed in square brackets and separated by commas; for example:
\par 
\par [ 0 0 0, 1.2 3.4 5.6, 98.6 -4e1 212 ]
\par 
\par    Nodes
\par 
\par VRML defines several different classes of nodes. Most of the nodes can be
\par classified into one of three categories; shape, property or group. Shape nodes
\par define the geometry in the scene. Conceptually, they are the only nodes that
\par draw anything. Property nodes affect the way shapes are drawn. And grouping
\par nodes gather other nodes together, allowing collections of nodes to be treated
\par as a single object. Some group nodes also control whether or not their children
\par are drawn.
\par 
\par Nodes may contain zero or more fields. Each node type defines the type, name,
\par and default value for each of its fields. The default value for the field is
\par used if a value for the field is not specified in the VRML file. The order in
\par which the fields of a node are read is not important; for example, "Cube \{
\par width 2 height 4 depth 6 \}" and "Cube \{ height 4 depth 6 width 2 \}" are
\par equivalent.
\par 
\par Here are the 36 nodes grouped by type. The first group are the shape nodes.
\par These specify geometry:
\par 
\par AsciiText, Cone, Cube, Cylinder, IndexedFaceSet, IndexedLineSet, PointSet,
\par Sphere,
\par 
\par The second group are the properties. These can be further grouped into
\par properties of the geometry and its appearance, matrix or transform properties,
\par and cameras and lights: Coordinate3, FontStyle, Info, LOD, Material,
\par MaterialBinding, Normal, NormalBinding, Texture2, Texture2Transform,
\par TextureCoordinate2, ShapeHints
\par 
\par MatrixTransform, Rotation, Scale, Transform, Translation
\par 
\par OrthographicCamera, PerspectiveCamera
\par 
\par DirectionalLight, PointLight, SpotLight
\par 
\par These are the group nodes:
\par 
\par Group, Separator, Switch, TransformSeparator, WWWAnchor
\par 
\par Finally, the WWWInline node does not fit neatly into any category.
\par 
\par WWWInline
\par 
\par AsciiText
\par 
\par This node represents strings of text characters from the ASCII coded character
\par set. The first string is rendered with its baseline at (0,0,0). All subsequent
\par strings advance y by -(size * spacing). See FontStyle for a description of the
\par size field. The justification field determines the placement of the strings in
\par the x dimension. LEFT (the default) places the left edge of each string at x=0.
\par CENTER places the center of each string at x=0. RIGHT places the right edge of
\par each string at x=0. Text is rendered from left to right, top to bottom in the
\par font set by FontStyle. The width field defines a suggested width constraint for
\par each string. The default is to use the natural width of each string. Setting
\par any value to 0 indicates the natural width should be used for that string.
\par 
\par The text is transformed by the current cumulative transformation and is drawn
\par with the current material and texture.
\par 
\par Textures are applied to 3D text as follows. The texture origin is at the origin
\par of the first string, as determined by the justification. The texture is scaled
\par equally in both S and T dimensions, with the font height representing 1 unit. S
\par increases to the right. The T origin can occur anywhere along each character,
\par depending on how that character's outline is defined.
\par 
\par JUSTIFICATION
\par      LEFT     Align left edge of text to origin
\par      CENTER   Align center of text to origin
\par      RIGHT    Align right edge of text to origin
\par 
\par FILE FORMAT/DEFAULTS
\par      AsciiText \{
\par           string         ""    # MFString
\par           spacing        1     # SFFloat
\par           justification  LEFT  # SFEnum
\par           width          0     # MFFloat
\par      \}
\par 
\par Cone
\par 
\par This node represents a simple cone whose central axis is aligned with the
\par y-axis. By default, the cone is centered at (0,0,0) and has a size of -1 to +1
\par in all three directions. The cone has a radius of 1 at the bottom and a height
\par of 2, with its apex at 1 and its bottom at -1. The cone has two parts: the
\par sides and the bottom.
\par 
\par The cone is transformed by the current cumulative transformation and is drawn
\par with the current texture and material.
\par 
\par If the current material binding is PER_PART or PER_PART_INDEXED, the first
\par current material is used for the sides of the cone, and the second is used for
\par the bottom. Otherwise, the first material is used for the entire cone.
\par 
\par When a texture is applied to a cone, it is applied differently to the sides and
\par bottom. On the sides, the texture wraps counterclockwise (from above) starting
\par at the back of the cone. The texture has a vertical seam at the back,
\par intersecting the yz-plane. For the bottom, a circle is cut out of the texture
\par square and applied to the cone's base circle. The texture appears right side up
\par when the top of the cone is rotated towards the -Z axis.
\par 
\par PARTS
\par      SIDES       The conical part
\par      BOTTOM      The bottom circular face
\par      ALL         All parts
\par 
\par FILE FORMAT/DEFAULTS
\par      Cone \{
\par           parts         ALL     # SFBitMask
\par           bottomRadius  1       # SFFloat
\par           height        2       # SFFloat
\par      \}
\par 
\par Coordinate3
\par 
\par This node defines a set of 3D coordinates to be used by a subsequent
\par IndexedFaceSet, IndexedLineSet, or PointSet node. This node does not produce a
\par visible result during rendering; it simply replaces the current coordinates in
\par the rendering state for subsequent nodes to use.
\par 
\par FILE FORMAT/DEFAULTS
\par      Coordinate3 \{
\par           point  0 0 0  # MFVec3f
\par      \}
\par 
\par Cube
\par 
\par This node represents a cuboid aligned with the coordinate axes. By default, the
\par cube is centered at (0,0,0) and measures 2 units in each dimension, from -1 to
\par +1. The cube is transformed by the current cumulative transformation and is
\par drawn with the current material and texture.
\par 
\par If the current material binding is PER_PART, PER_PART_INDEXED, PER_FACE, or
\par PER_FACE_INDEXED, materials will be bound to the faces of the cube in this
\par order: front (+Z), back (-Z), left (-X), right (+X), top (+Y), and bottom (-Y).
\par 
\par Textures are applied individually to each face of the cube; the entire texture
\par goes on each face. On the front, back, right, and left sides of the cube, the
\par texture is applied right side up. On the top, the texture appears right side up
\par when the top of the cube is tilted toward the camera. On the bottom, the
\par texture appears right side up when the top of the cube is tilted towards the -Z
\par axis.
\par 
\par FILE FORMAT/DEFAULTS
\par      Cube \{
\par           width   2     # SFFloat
\par           height  2     # SFFloat
\par           depth   2     # SFFloat
\par      \}
\par 
\par Cylinder
\par 
\par This node represents a simple capped cylinder centered around the y-axis. By
\par default, the cylinder is centered at (0,0,0) and has a default size of -1 to +1
\par in all three dimensions. The cylinder has three parts: the sides, the top (y =
\par +1) and the bottom (y = -1). You can use the radius and height fields to create
\par a cylinder with a different size.
\par 
\par The cylinder is transformed by the current cumulative transformation and is
\par drawn with the current material and texture.
\par 
\par If the current material binding is PER_PART or PER_PART_INDEXED, the first
\par current material is used for the sides of the cylinder, the second is used for
\par the top, and the third is used for the bottom. Otherwise, the first material is
\par used for the entire cylinder.
\par 
\par When a texture is applied to a cylinder, it is applied differently to the
\par sides, top, and bottom. On the sides, the texture wraps counterclockwise (from
\par above) starting at the back of the cylinder. The texture has a vertical seam at
\par the back, intersecting the yz-plane. For the top and bottom, a circle is cut
\par out of the texture square and applied to the top or bottom circle. The top
\par texture appears right side up when the top of the cylinder is tilted toward the
\par +Z axis, and the bottom texture appears right side up when the top of the
\par cylinder is tilted toward the -Z axis.
\par 
\par PARTS
\par      SIDES   The cylindrical part
\par      TOP     The top circular face
\par      BOTTOM  The bottom circular face
\par      ALL     All parts
\par 
\par FILE FORMAT/DEFAULTS
\par      Cylinder \{
\par           parts   ALL   # SFBitMask
\par           radius  1     # SFFloat
\par           height  2     # SFFloat
\par      \}
\par 
\par DirectionalLight
\par 
\par This node defines a directional light source that illuminates along rays
\par parallel to a given 3-dimensional vector.
\par 
\par A light node defines an illumination source that may affect subsequent shapes
\par in the scene graph, depending on the current lighting style. Light sources are
\par affected by the current transformation. A light node under a separator does not
\par affect any objects outside that separator.
\par 
\par FILE FORMAT/DEFAULTS
\par      DirectionalLight \{
\par           on         TRUE       # SFBool
\par           intensity  1          # SFFloat
\par           color      1 1 1      # SFColor
\par           direction  0 0 -1     # SFVec3f
\par      \}
\par 
\par FontStyle
\par 
\par This node defines the current font style used for all subsequent AsciiText.
\par Font attributes only are defined. It is up to the browser to assign specific
\par fonts to the various attribute combinations. The size field specifies the
\par height (in object space units) of glyphs rendered and determines the vertical
\par spacing of adjacent lines of text.
\par 
\par FAMILY
\par 
\par      SERIF       Serif style (such as TimesRoman)
\par      SANS        Sans Serif Style (such as Helvetica)
\par      TYPEWRITER  Fixed pitch style (such as Courier)
\par 
\par STYLE
\par      NONE        No modifications to family
\par      BOLD        Embolden family
\par      ITALIC      Italicize or Slant family
\par 
\par FILE FORMAT/DEFAULTS
\par      FontStyle \{
\par           size     10      # SFFloat
\par           family   SERIF   # SFEnum
\par           style    NONE    # SFBitMask
\par      \}
\par 
\par Group
\par 
\par This node defines the base class for all group nodes. Group is a node that
\par contains an ordered list of child nodes. This node is simply a container for
\par the child nodes and does not alter the traversal state in any way. During
\par traversal, state accumulated for a child is passed on to each successive child
\par and then to the parents of the group (Group does not push or pop traversal
\par state as separator does).
\par 
\par FILE FORMAT/DEFAULTS
\par      Group \{
\par      \}
\par 
\par IndexedFaceSet
\par 
\par This node represents a 3D shape formed by constructing faces (polygons) from
\par vertices located at the current coordinates. IndexedFaceSet uses the indices in
\par its coordIndex field to specify the polygonal faces. An index of -1 indicates
\par that the current face has ended and the next one begins.
\par 
\par The vertices of the faces are transformed by the current transformation matrix.
\par 
\par Treatment of the current material and normal binding is as follows: The
\par PER_PART and PER_FACE bindings specify a material or normal for each face.
\par PER_VERTEX specifies a material or normal for each vertex. The corresponding
\par _INDEXED bindings are the same, but use the materialIndex or normalIndex
\par indices. The DEFAULT material binding is equal to OVERALL. The DEFAULT normal
\par binding is equal to PER_VERTEX_INDEXED; if insufficient normals exist in the
\par state, vertex normals will be generated automatically.
\par 
\par Explicit texture coordinates (as defined by TextureCoordinate2) may be bound to
\par vertices of an indexed shape by using the indices in the textureCoordIndex
\par field. As with all vertex-based shapes, if there is a current texture but no
\par texture coordinates are specified, a default texture coordinate mapping is
\par calculated using the bounding box of the shape. The longest dimension of the
\par bounding box defines the S coordinates, and the next longest defines the T
\par coordinates. The value of the S coordinate ranges from 0 to 1, from one end of
\par the bounding box to the other. The T coordinate ranges between 0 and the ratio
\par of the second greatest dimension of the bounding box to the greatest dimension.
\par 
\par Be sure that the indices contained in the coordIndex, materialIndex,
\par normalIndex, and textureCoordIndex fields are valid with respect to the current
\par state, or errors will occur.
\par 
\par FILE FORMAT/DEFAULTS
\par      IndexedFaceSet \{
\par           coordIndex         0  # MFLong
\par           materialIndex      -1 # MFLong
\par           normalIndex        -1 # MFLong
\par           textureCoordIndex  -1 # MFLong
\par      \}
\par 
\par IndexedLineSet
\par 
\par This node represents a 3D shape formed by constructing polylines from vertices
\par located at the current coordinates. IndexedLineSet uses the indices in its
\par coordIndex field to specify the polylines. An index of -1 indicates that the
\par current polyline has ended and the next one begins.
\par 
\par The coordinates of the line set are transformed by the current cumulative
\par transformation.
\par 
\par Treatment of the current material and normal binding is as follows: The
\par PER_PART binding specifies a material or normal for each segment of the line.
\par The PER_FACE binding specifies a material or normal for each polyline.
\par PER_VERTEX specifies a material or normal for each vertex. The corresponding
\par _INDEXED bindings are the same, but use the materialIndex or normalIndex
\par indices. The DEFAULT material binding is equal to OVERALL. The DEFAULT normal
\par binding is equal to PER_VERTEX_INDEXED; if insufficient normals exist in the
\par state, the lines will be drawn unlit. The same rules for texture coordinate
\par generation as IndexedFaceSet are used.
\par 
\par FILE FORMAT/DEFAULTS
\par      IndexedLineSet \{
\par           coordIndex         0  # MFLong
\par           materialIndex      -1 # MFLong
\par           normalIndex        -1 # MFLong
\par           textureCoordIndex  -1 # MFLong
\par      \}
\par 
\par Info
\par 
\par This class defines an information node in the scene graph. This node has no
\par effect during traversal. It is used to store information in the scene graph,
\par typically for application-specific purposes, copyright messages, or other
\par strings.
\par 
\par      Info \{
\par           string  "<Undefined info>"      # SFString
\par      \}
\par 
\par LOD
\par 
\par This group node is used to allow applications to switch between various
\par representations of objects automatically. The children of this node typically
\par represent the same object or objects at varying levels of detail, from highest
\par detail to lowest.
\par 
\par The specified center point of the LOD is transformed by the current
\par transformation into world space, and the distance from the transformed center
\par to the world-space eye point is calculated. If the distance is less than the
\par first value in the ranges array, then the first child of the LOD group is
\par drawn. If between the first and second values in the ranges array, the second
\par child is drawn, etc. If there are N values in the ranges array, the LOD group
\par should have N+1 children. Specifying too few children will result in the last
\par child being used repeatedly for the lowest levels of detail; if too many
\par children are specified, the extra children will be ignored. Each value in the
\par ranges array should be less than the previous value, otherwise results are
\par undefined.
\par 
\par FILE FORMAT/DEFAULTS
\par      LOD \{
\par           range [ ]    # MFFloat
\par           center 0 0 0  # SFVec3f
\par      \}
\par 
\par Material
\par 
\par This node defines the current surface material properties for all subsequent
\par shapes. Material sets several components of the current material during
\par traversal. Different shapes interpret materials with multiple values
\par differently. To bind materials to shapes, use a MaterialBinding node.
\par 
\par FILE FORMAT/DEFAULTS
\par      Material \{
\par           ambientColor   0.2 0.2 0.2    # MFColor
\par           diffuseColor   0.8 0.8 0.8    # MFColor
\par           specularColor  0 0 0          # MFColor
\par           emissiveColor  0 0 0          # MFColor
\par           shininess      0.2            # MFFloat
\par           transparency   0              # MFFloat
\par      \}
\par 
\par MaterialBinding
\par 
\par This node specifies how the current materials are bound to shapes that follow
\par in the scene graph. Each shape node may interpret bindings differently. The
\par current material always has a base value, which is defined by the first value
\par of all material fields. Since material fields may have multiple values, the
\par binding determines how these values are distributed over a shape.
\par 
\par The bindings for faces and vertices are meaningful only for shapes that are
\par made from faces and vertices. Similarly, the indexed bindings are only used by
\par the shapes that allow indexing.
\par 
\par When multiple material values are bound, the values are cycled through, based
\par on the period of the material component with the most values. For example, the
\par following table shows the values used when cycling through (or indexing into) a
\par material with 2 ambient colors, 3 diffuse colors, and 1 of all other components
\par in the current material. (The period of this material cycle is 3):
\par 
\par Material        Ambient color   Diffuse color   Other
\par  0                     0               0           0
\par  1                     1               1           0
\par  2                     1               2           0
\par  3 (same as 0)         0               0           0
\par 
\par BINDINGS
\par      DEFAULT            Use default binding
\par      OVERALL            Whole object has same material
\par      PER_PART           One material for each part of object
\par      PER_PART_INDEXED   One material for each part, indexed
\par      PER_FACE           One material for each face of object
\par      PER_FACE_INDEXED   One material for each face, indexed
\par      PER_VERTEX         One material for each vertex of object
\par      PER_VERTEX_INDEXED One material for each vertex, indexed
\par 
\par FILE FORMAT/DEFAULTS
\par      MaterialBinding \{
\par           value  DEFAULT        # SFEnum
\par      \}
\par 
\par MatrixTransform
\par 
\par This node defines a geometric 3D transformation with a 4 by 4 matrix. Note that
\par some matrices (such as singular ones) may result in errors.
\par 
\par FILE FORMAT/DEFAULTS
\par      MatrixTransform \{
\par           matrix  1 0 0 0       # SFMatrix
\par                   0 1 0 0
\par                   0 0 1 0
\par                   0 0 0 1
\par      \}
\par 
\par Normal
\par 
\par This node defines a set of 3D surface normal vectors to be used by vertex-based
\par shape nodes (IndexedFaceSet, IndexedLineSet, PointSet) that follow it in the
\par scene graph. This node does not produce a visible result during rendering; it
\par simply replaces the current normals in the rendering state for subsequent nodes
\par to use. This node contains one multiple-valued field that contains the normal
\par vectors.
\par 
\par FILE FORMAT/DEFAULTS
\par      Normal \{
\par           vector  0 0 1 # MFVec3f
\par      \}
\par 
\par NormalBinding
\par 
\par This node specifies how the current normals are bound to shapes that follow in
\par the scene graph. Each shape node may interpret bindings differently.
\par 
\par The bindings for faces and vertices are meaningful only for shapes that are
\par made from faces and vertices. Similarly, the indexed bindings are only used by
\par the shapes that allow indexing. For bindings that require multiple normals, be
\par sure to have at least as many normals defined as are necessary; otherwise,
\par errors will occur.
\par 
\par BINDINGS
\par      DEFAULT            Use default binding
\par      OVERALL            Whole object has same normal
\par      PER_PART           One normal for each part of object
\par      PER_PART_INDEXED   One normal for each part, indexed
\par      PER_FACE           One normal for each face of object
\par      PER_FACE_INDEXED   One normal for each face, indexed
\par      PER_VERTEX         One normal for each vertex of object
\par      PER_VERTEX_INDEXED One normal for each vertex, indexed
\par 
\par FILE FORMAT/DEFAULTS
\par      NormalBinding \{
\par           value  DEFAULT        # SFEnum
\par      \}
\par 
\par OrthographicCamera
\par 
\par An orthographic camera defines a parallel projection from a viewpoint. This
\par camera does not diminish objects with distance, as an PerspectiveCamera does.
\par The viewing volume for an orthographic camera is a rectangular parallelepiped
\par (a box).
\par 
\par By default, the camera is located at (0,0,1) and looks along the negative
\par z-axis; the position and orientation fields can be used to change these values.
\par The height field defines the total height of the viewing volume.
\par 
\par A camera can be placed in a VRML world to specify the initial location of the
\par viewer when that world is entered. VRML browsers will typically modify the
\par camera to allow a user to move through the virtual world.
\par 
\par Cameras are affected by the current transformation, so you can position a
\par camera by placing a transformation node before it in the scene graph . The
\par default position and orientation of a camera is at (0,0,1) looking along the
\par negative z-axis.
\par 
\par FILE FORMAT/DEFAULTS
\par      OrthographicCamera \{
\par           position         0 0 1        # SFVec3f
\par           orientation      0 0 1  0     # SFRotation
\par           focalDistance    5            # SFFloat
\par           height           2            # SFFloat
\par      \}
\par 
\par PerspectiveCamera
\par 
\par A perspective camera defines a perspective projection from a viewpoint. The
\par viewing volume for a perspective camera is a truncated right pyramid.
\par 
\par By default, the camera is located at (0,0,1) and looks along the negative
\par z-axis; the position and orientation fields can be used to change these values.
\par The heightAngle field defines the total vertical angle of the viewing volume.
\par 
\par See more on cameras in the OrthographicCamera description.
\par 
\par FILE FORMAT/DEFAULTS
\par      PerspectiveCamera \{
\par           position         0 0 1        # SFVec3f
\par           orientation      0 0 1  0     # SFRotation
\par           focalDistance    5            # SFFloat
\par           heightAngle      0.785398     # SFFloat
\par      \}
\par 
\par PointLight
\par 
\par This node defines a point light source at a fixed 3D location. A point source
\par illuminates equally in all directions; that is, it is omni- directional.
\par 
\par A light node defines an illumination source that may affect subsequent shapes
\par in the scene graph, depending on the current lighting style. Light sources are
\par affected by the current transformation. A light node under a separator does not
\par affect any objects outside that separator.
\par 
\par FILE FORMAT/DEFAULTS
\par      PointLight \{
\par           on         TRUE       # SFBool
\par           intensity  1          # SFFloat
\par           color      1 1 1      # SFColor
\par           location   0 0 1      # SFVec3f
\par      \}
\par 
\par PointSet
\par 
\par This node represents a set of points located at the current coordinates.
\par PointSet uses the current coordinates in order, starting at the index specified
\par by the startIndex field. The number of points in the set is specified by the
\par numPoints field. A value of -1 for this field indicates that all remaining
\par values in the current coordinates are to be used as points.
\par 
\par The coordinates of the point set are transformed by the current cumulative
\par transformation. The points are drawn with the current material and texture.
\par 
\par Treatment of the current material and normal binding is as follows: PER_PART,
\par PER_FACE, and PER_VERTEX bindings bind one material or normal to each point.
\par The DEFAULT material binding is equal to OVERALL. The DEFAULT normal binding is
\par equal to PER_VERTEX. The startIndex is also used for materials or normals when
\par the binding indicates that they should be used per vertex.
\par 
\par FILE FORMAT/DEFAULTS
\par      PointSet \{
\par           startIndex  0 # SFLong
\par           numPoints   -1        # SFLong
\par      \}
\par 
\par Rotation
\par 
\par This node defines a 3D rotation about an arbitrary axis through the origin. The
\par rotation is accumulated into the current transformation, which is applied to
\par subsequent shapes.
\par 
\par FILE FORMAT/DEFAULTS
\par      Rotation \{
\par           rotation  0 0 1  0    # SFRotation
\par      \}
\par 
\par See rotation field description for more information.
\par 
\par Scale
\par 
\par This node defines a 3D scaling about the origin. If the components of the
\par scaling vector are not all the same, this produces a non-uniform scale.
\par 
\par FILE FORMAT/DEFAULTS
\par      Scale \{
\par           scaleFactor  1 1 1    # SFVec3f
\par      \}
\par 
\par Separator
\par 
\par This group node performs a push (save) of the traversal state before traversing
\par its children and a pop (restore) after traversing them. This isolates the
\par separator's children from the rest of the scene graph. A separator can include
\par lights, cameras, coordinates, normals, bindings, and all other properties.
\par 
\par Separators can also perform render culling. Render culling skips over traversal
\par of the separator's children if they are not going to be rendered, based on the
\par comparison of the separator's bounding box with the current view volume.
\par Culling is controlled by the renderCulling field. These are set to AUTO by
\par default, allowing the implementation to decide whether or not to cull.
\par 
\par CULLING ENUMS
\par      ON    Always try to cull to the view volume
\par      OFF   Never try to cull to the view volume
\par      AUTO  Implementation-defined culling behavior
\par 
\par FILE FORMAT/DEFAULTS
\par      Separator \{
\par           renderCulling       AUTO      # SFEnum
\par      \}
\par 
\par ShapeHints
\par 
\par The ShapeHints node indicates that IndexedFaceSets are solid, contain ordered
\par vertices, or contain convex faces.
\par 
\par These hints allow VRML implementations to optimize certain rendering features.
\par Optimizations that may be performed include enabling back-face culling and
\par disabling two-sided lighting. For example, if an object is solid and has
\par ordered vertices, an implementation may turn on backface culling and turn off
\par two-sided lighting. If the object is not solid but has ordered vertices, it may
\par turn off backface culling and turn on two-sided lighting.
\par 
\par The ShapeHints node also affects how default normals are generated. When an
\par IndexedFaceSet has to generate default normals, it uses the creaseAngle field
\par to determine which edges should be smoothly shaded and which ones should have a
\par sharp crease. The crease angle is the angle between surface normals on adjacent
\par polygons. For example, a crease angle of .5 radians (the default value) means
\par that an edge between two adjacent polygonal faces will be smooth shaded if the
\par normals to the two faces form an angle that is less than .5 radians (about 30
\par degrees). Otherwise, it will be faceted.
\par 
\par VERTEX ORDERING ENUMS
\par      UNKNOWN_ORDERING    Ordering of vertices is unknown
\par      CLOCKWISE           Face vertices are ordered clockwise
\par                           (from the outside)
\par      COUNTERCLOCKWISE    Face vertices are ordered counterclockwise
\par                           (from the outside)
\par 
\par SHAPE TYPE ENUMS
\par      UNKNOWN_SHAPE_TYPE  Nothing is known about the shape
\par      SOLID               The shape encloses a volume
\par 
\par FACE TYPE ENUMS
\par      UNKNOWN_FACE_TYPE   Nothing is known about faces
\par      CONVEX              All faces are convex
\par 
\par FILE FORMAT/DEFAULTS
\par      ShapeHints \{
\par           vertexOrdering  UNKNOWN_ORDERING      # SFEnum
\par           shapeType       UNKNOWN_SHAPE_TYPE    # SFEnum
\par           faceType        CONVEX                # SFEnum
\par           creaseAngle     0.5                   # SFFloat
\par      \}
\par 
\par Sphere
\par 
\par This node represents a sphere. By default, the sphere is centered at the origin
\par and has a radius of 1. The sphere is transformed by the current cumulative
\par transformation and is drawn with the current material and texture.
\par 
\par A sphere does not have faces or parts. Therefore, the sphere ignores material
\par and normal bindings, using the first material for the entire sphere and using
\par its own normals. When a texture is applied to a sphere, the texture covers the
\par entire surface, wrapping counterclockwise from the back of the sphere. The
\par texture has a seam at the back on the yz-plane.
\par 
\par FILE FORMAT/DEFAULTS
\par      Sphere \{
\par           radius  1     # SFFloat
\par      \}
\par 
\par SpotLight
\par 
\par This node defines a spotlight light source. A spotlight is placed at a fixed
\par location in 3-space and illuminates in a cone along a particular direction. The
\par intensity of the illumination drops off exponentially as a ray of light
\par diverges from this direction toward the edges of the cone. The rate of drop-off
\par and the angle of the cone are controlled by the dropOffRate and cutOffAngle
\par fields.
\par 
\par A light node defines an illumination source that may affect subsequent shapes
\par in the scene graph, depending on the current lighting style. Light sources are
\par affected by the current transformation. A light node under a separator does not
\par affect any objects outside that separator.
\par 
\par FILE FORMAT/DEFAULTS
\par      SpotLight \{
\par           on           TRUE     # SFBool
\par           intensity    1        # SFFloat
\par           color        1 1 1    # SFVec3f
\par           location     0 0 1    # SFVec3f
\par           direction    0 0 -1   # SFVec3f
\par           dropOffRate  0        # SFFloat
\par           cutOffAngle  0.785398 # SFFloat
\par      \}
\par 
\par Switch
\par 
\par This group node traverses one, none, or all of its children. One can use this
\par node to switch on and off the effects of some properties or to switch between
\par different properties.
\par 
\par The whichChild field specifies the index of the child to traverse, where the
\par first child has index 0.
\par 
\par A value of -1 (the default) means do not traverse any children. A value of -3
\par traverses all children, making the switch behave exactly like a regular Group.
\par 
\par FILE FORMAT/DEFAULTS
\par      Switch \{
\par           whichChild  -1        # SFLong
\par      \}
\par 
\par Texture2
\par 
\par This property node defines a texture map and parameters for that map. This map
\par is used to apply texture to subsequent shapes as they are rendered.
\par 
\par The texture can be read from the URL specified by the filename field. To turn
\par off texturing, set the filename field to an empty string ("").
\par 
\par Textures can also be specified inline by setting the image field to contain the
\par texture data. Specifying both a URL and data inline will result in undefined
\par behavior.
\par 
\par WRAP ENUM
\par      REPEAT  Repeats texture outside 0-1 texture coordinate range
\par      CLAMP   Clamps texture coordinates to lie within 0-1 range
\par 
\par FILE FORMAT/DEFAULTS
\par      Texture2 \{
\par           filename    ""        # SFString
\par           image       0 0 0     # SFImage
\par           wrapS       REPEAT    # SFEnum
\par           wrapT       REPEAT    # SFEnum
\par      \}
\par 
\par Texture2Transform
\par 
\par This node defines a 2D transformation applied to texture coordinates. This
\par affects the way textures are applied to the surfaces of subsequent shapes. The
\par transformation consists of (in order) a non-uniform scale about an arbitrary
\par center point, a rotation about that same point, and a translation. This allows
\par a user to change the size and position of the textures on shapes.
\par 
\par FILE FORMAT/DEFAULTS
\par      Texture2Transform \{
\par           translation  0 0      # SFVec2f
\par           rotation     0        # SFFloat
\par           scaleFactor  1 1      # SFVec2f
\par           center       0 0      # SFVec2f
\par      \}
\par 
\par TextureCoordinate2
\par 
\par This node defines a set of 2D coordinates to be used to map textures to the
\par vertices of subsequent PointSet, IndexedLineSet, or IndexedFaceSet objects. It
\par replaces the current texture coordinates in the rendering state for the shapes
\par to use.
\par 
\par Texture coordinates range from 0 to 1 across the texture. The horizontal
\par coordinate, called S, is specified first, followed by the vertical coordinate,
\par T.
\par 
\par FILE FORMAT/DEFAULTS
\par      TextureCoordinate2 \{
\par           point  0 0    # MFVec2f
\par      \}
\par 
\par Transform
\par 
\par This node defines a geometric 3D transformation consisting of (in order) a
\par (possibly) non-uniform scale about an arbitrary point, a rotation about an
\par arbitrary point and axis, and a translation.
\par 
\par FILE FORMAT/DEFAULTS
\par      Transform \{
\par           translation       0 0 0       # SFVec3f
\par           rotation          0 0 1  0    # SFRotation
\par           scaleFactor       1 1 1       # SFVec3f
\par           scaleOrientation  0 0 1  0    # SFRotation
\par           center            0 0 0       # SFVec3f
\par      \}
\par 
\par The transform node
\par 
\par Transform \{
\par     translation T1
\par     rotation R1
\par     scaleFactor S
\par     scaleOrientation R2
\par     center T2
\par   \}
\par 
\par is equivalent to the sequence
\par 
\par Translation \{ translation T1 \}
\par Translation \{ translation T2 \}
\par Rotation \{ rotation R1 \}
\par Rotation \{ rotation R2 \}
\par Scale \{ scaleFactor S \}
\par Rotation \{ rotation -R2 \}
\par Translation \{ translation -T2 \}
\par 
\par TransformSeparator
\par 
\par This group node is similar to the separator node in that it saves state before
\par traversing its children and restores it afterwards. However, it saves only the
\par current transformation; all other state is left as is. This node can be useful
\par for positioning a camera, since the transformations to the camera will not
\par affect the rest of the scene, even through the camera will view the scene.
\par Similarly, this node can be used to isolate transformations to light sources or
\par other objects.
\par 
\par FILE FORMAT/DEFAULTS
\par      TransformSeparator \{
\par      \}
\par 
\par Translation
\par 
\par This node defines a translation by a 3D vector.
\par 
\par FILE FORMAT/DEFAULTS
\par      Translation \{
\par           translation  0 0 0    # SFVec3f
\par      \}
\par 
\par WWWAnchor
\par 
\par The WWWAnchor group node loads a new scene into a VRML browser when one of its
\par children is chosen. Exactly how a user "chooses" a child of the WWWAnchor is up
\par to the VRML browser; typically, clicking on one of its children with the mouse
\par will result in the new scene replacing the current scene. A WWWAnchor with an
\par empty ("") name does nothing when its children are chosen. The name is an
\par arbitrary URL.
\par 
\par WWWAnchor behaves like a Separator, pushing the traversal state before
\par traversing its children and popping it afterwards.
\par 
\par The description field in the WWWAnchor allows for a friendly prompt to be
\par displayed as an alternative to the URL in the name field. Ideally, browsers
\par will allow the user to choose the description, the URL or both to be displayed
\par for a candidate WWWAnchor.
\par 
\par The WWWAnchor's map field is an enumerated value that can be either NONE (the
\par default) or POINT. If it is POINT then the object-space coordinates of the
\par point on the object the user chose will be added to the URL in the name field,
\par with the syntax "?x,y,z".
\par 
\par MAP ENUM
\par      NONE  Do not add information to the URL
\par      POINT Add object-space coordinates to URL
\par 
\par FILE FORMAT/DEFAULTS
\par      WWWAnchor \{
\par           name ""        # SFString
\par           description "" # SFString
\par           map NONE       # SFEnum
\par      \}
\par 
\par WWWInline
\par 
\par The WWWInline node reads its children from anywhere in the World Wide Web.
\par Exactly when its children are read is not defined; reading the children may be
\par delayed until the WWWInline is actually displayed. A WWWInline with an empty
\par name does nothing. The name is an arbitrary URL.
\par 
\par The effect of referring to a non-VRML URL in a WWWInline node is undefined.
\par 
\par If the WWWInline's bboxSize field specifies a non-empty bounding box (a
\par bounding box is non-empty if at least one of its dimensions is greater than
\par zero), then the WWWInline's object-space bounding box is specified by its
\par bboxSize and bboxCenter fields. This allows an implementation to view-volume
\par cull or LOD switch the WWWInline without reading its contents.
\par 
\par FILE FORMAT/DEFAULTS
\par      WWWInline \{
\par           name ""               # SFString
\par           bboxSize 0 0 0        # SFVec3f
\par           bboxCenter 0 0 0      # SFVec3f
\par      \}
\par 
\par    Instancing
\par 
\par A node may be the child of more than one group. This is called "instancing"
\par (using the same instance of a node multiple times, called "aliasing" or
\par "multiple references" by other systems), and is accomplished by using the "USE"
\par keyword.
\par 
\par The DEF keyword both defines a named node, and creates a single instance of it.
\par The USE keyword indicates that the most recently defined instance should be
\par used again. If several nodes were given the same name, then the last DEF
\par encountered during parsing "wins". DEF/USE is limited to a single file; there
\par is no mechanism for USE'ing nodes that are DEF'ed in other files.
\par 
\par A name goes into scope as soon as the DEF is encountered, and does not go out
\par of scope until another DEF of the same name or end-of-file are encountered.
\par Nodes cannot be shared between files (you cannot USE a node that was DEF'ed
\par inside the file to which a WWWInline refers).
\par 
\par For example, rendering this scene will result in three spheres being drawn.
\par Both of the spheres are named 'Joe'; the second (smaller) sphere is drawn
\par twice:
\par 
\par Separator \{
\par         DEF Joe Sphere \{ \}
\par         Translation \{ translation 2 0 0 \}
\par         Separator \{
\par                 DEF Joe Sphere \{ radius .2 \}
\par                 Translation \{ translation 2 0 0 \}
\par         \}
\par         USE Joe    # radius .2 sphere will be used here
\par 
\par 
\par    Extensibility
\par 
\par Extensions to VRML are supported by supporting self-describing nodes. Nodes
\par that are not part of standard VRML must write out a description of their fields
\par first, so that all VRML implementations are able to parse and ignore the
\par extensions.
\par 
\par This description is written just after the opening curly-brace for the node,
\par and consists of the keyword 'fields' followed by a list of the types and names
\par of fields used by that node, all enclosed in square brackets and separated by
\par commas. For example, if Cube was not a standard VRML node, it would be written
\par like this:
\par 
\par Cube \{
\par   fields [ SFFloat width, SFFloat height, SFFloat depth ]
\par   width 10 height 4 depth 3
\par 
\par 
\par Specifying the fields for nodes that ARE part of standard VRML is not an error;
\par VRML parsers must silently ignore the field specification.
\par 
\par Is-a relationships
\par 
\par A new node type may also be a superset of an existing node that is part of the
\par standard. In this case, if an implementation for the new node type cannot be
\par found the new node type can be safely treated as as the existing node it is
\par based on (with some loss of functionality, of course). To support this, new
\par node types can define an MFString field called 'isA' containing the names of
\par the types of which it is a superset. For example, a new type of Material called
\par "ExtendedMaterial" that adds index of refraction as a material property can be
\par written as:
\par 
\par ExtendedMaterial \{
\par   fields [ MFString isA, MFFloat indexOfRefraction,
\par            MFColor ambientColor, MFColor diffuseColor,
\par            MFColor specularColor, MFColor emissiveColor,
\par            MFFloat shininess, MFFloat transparency ]
\par   isA [ "Material" ]
\par   indexOfRefraction .34
\par   diffuseColor .8 .54 1
\par 
\par 
\par Multiple is-a relationships may be specified in order of preference;
\par implementations are expected to use the first for which there is an
\par implementation.
\par 
\par    An Example
\par 
\par This is a longer example of a VRML scene. It contains a simple model of a
\par track-light consisting of primitive shapes, plus three walls (built out of
\par polygons) and a reference to a shape defined elsewhere, both of which are
\par illuminated by a spotlight. The shape acts as a hyperlink to some HTML text.
\par 
\par #VRML V1.0 ascii
\par 
\par Separator \{
\par     Separator \{       # Simple track-light geometry:
\par         Translation \{ translation 0 4 0 \}
\par         Separator \{
\par             Material \{ emissiveColor 0.1 0.3 0.3 \}
\par             Cube \{
\par                 width   0.1
\par                 height  0.1
\par                 depth   4
\par             \}
\par         \}
\par         Rotation \{ rotation 0 1 0  1.57079 \}
\par         Separator \{
\par             Material \{ emissiveColor 0.3 0.1 0.3 \}
\par             Cylinder \{
\par                 radius  0.1
\par                 height  .2
\par             \}
\par         \}
\par         Rotation \{ rotation -1 0 0  1.57079 \}
\par         Separator \{
\par             Material \{ emissiveColor 0.3 0.3 0.1 \}
\par             Rotation \{ rotation 1 0 0  1.57079 \}
\par             Translation \{ translation 0 -.2 0 \}
\par             Cone \{
\par                 height  .4
\par                 bottomRadius .2
\par             \}
\par             Translation \{ translation 0 .4 0 \}
\par             Cylinder \{
\par                 radius  0.02
\par                 height  .4
\par             \}
\par         \}
\par     \}
\par     SpotLight \{      # Light from above
\par         location 0 4 0
\par         direction 0 -1 0
\par         intensity       0.9
\par         cutOffAngle     0.7
\par     \}
\par     Separator \{      # Wall geometry; just three flat polygons
\par         Coordinate3 \{
\par             point [
\par                    -2 0 -2, -2 0 2, 2 0 2, 2 0 -2,
\par                    -2 4 -2, -2 4 2, 2 4 2, 2 4 -2]
\par         \}
\par         IndexedFaceSet \{
\par             coordIndex [ 0, 1, 2, 3, -1,
\par                         0, 4, 5, 1, -1,
\par                         0, 3, 7, 4, -1
\par                         ]
\par         \}
\par     \}
\par     WWWAnchor \{   # A hyperlinked cow:
\par         name "http://www.foo.edu/CowProject/AboutCows.html"
\par 
\par         Separator \{
\par             Translation \{ translation 0 1 0 \}
\par             WWWInline \{   # Reference another object
\par                 name "http://www.foo.edu/3DObjects/cow.wrl"
\par             \}
\par         \}
\par     \}
\par 
\par 
\par -------------------------------------------------------------------------------
\par 
\par    Browser Considerations
\par 
\par This section describes the file naming and MIME conventions to be used in
\par building VRML browsers and configuring WWW browsers to work with them.
\par 
\par    File Extensions
\par 
\par The file extension for VMRL files is .wrl (for world).
\par 
\par    MIME
\par 
\par The MIME type for VRML files is defined as follows:
\par 
\par x-world/x-vrml
\par 
\par The MIME major type for 3D world descriptions is x-world. The MIME minor type
\par for VRML documents is x-vrml. Other 3D world descriptions, such as oogl for The
\par Geometry Center's Object-Oriented Geometry Language, or iv, for SGI's Open
\par Inventor ASCII format, can be supported by using different MIME minor types.
\par 
\par [--] 26-MAY-95
\par 
\par }
 